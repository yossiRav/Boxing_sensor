/*
 * ×—×™×™×©×Ÿ ××’×¨×•×£ ×‘×œ×•×˜×•×ª' - ××ª×•×§×Ÿ ×œ×× ×™×¢×ª ××›×•×ª ×›×•×–×‘×•×ª (×§×•×“ ××œ×)
 * ESP32 + 2x MPU6050 + Bluetooth Classic
 * 
 * ×¤×ª×¨×•×Ÿ ×œ×‘×¢×™×™×ª ××›×•×ª ×›×•×–×‘×•×ª ×›×©×”×—×™×™×©×Ÿ ×‘××¦×‘ ×™×¦×™×‘ ×—×“×©
 * 
 * ××™×§×•× ×—×™×™×©× ×™× ×¢×œ ×”×©×§:
 * ×—×™×™×©×Ÿ 1: ×¢×œ×™×•×Ÿ (×¨××©/×’×•×£) - SDA=21, SCL=22, ×›×ª×•×‘×ª=0x68
 * ×—×™×™×©×Ÿ 2: ×ª×—×ª×•×Ÿ (×›×‘×“) - SDA=25, SCL=26, ×›×ª×•×‘×ª=0x68
 * 
 * ×§×•×‘×¥: boxing_sensor_fixed_complete.ino
 * ×ª××¨×™×š: ×™×•×œ×™ 2025
 * ×§×•×“ ××œ× ×¢× ×× ×™×¢×ª ××›×•×ª ×›×•×–×‘×•×ª
 */

#include <Wire.h>
#include "BluetoothSerial.h"
#include <ArduinoJson.h>

// ×‘×œ×•×˜×•×ª'
BluetoothSerial SerialBT;
String device_name = "BoxingSensor_01";

// ×¤×™× ×™ I2C ×œ×©× ×™ ×—×™×™×©× ×™×
#define SDA1 21  // ×—×™×™×©×Ÿ ×¢×œ×™×•×Ÿ
#define SCL1 22
#define SDA2 25  // ×—×™×™×©×Ÿ ×ª×—×ª×•×Ÿ
#define SCL2 26

// ×›×ª×•×‘×•×ª ×—×™×™×©× ×™× - ×©× ×™×”× ×‘××•×ª×” ×›×ª×•×‘×ª (0x68)
#define MPU6050_ADDR1 0x68  // ×—×™×™×©×Ÿ ×¢×œ×™×•×Ÿ (AD0=GND)
#define MPU6050_ADDR2 0x68  // ×—×™×™×©×Ÿ ×ª×—×ª×•×Ÿ (AD0=GND) - ××•×ª×” ×›×ª×•×‘×ª!

// ×©× ×™ I2C buses
TwoWire I2C_1 = TwoWire(0);
TwoWire I2C_2 = TwoWire(1);

// ××‘× ×” × ×ª×•× ×™× ×œ×›×œ ×—×™×™×©×Ÿ
struct SensorData {
    float current_punch;
    float max_punch;
    int punch_count;
    float baseline_x, baseline_y, baseline_z;
    bool punch_detected;
    unsigned long last_detection;
    unsigned long last_punch_time;
    
    // ×§×œ×™×‘×¨×¦×™×” ×“×™× ××™×ª ××ª×§×“××ª - ×× ×™×¢×ª ××›×•×ª ×›×•×–×‘×•×ª
    float moving_avg_x, moving_avg_y, moving_avg_z;
    int stable_count;
    unsigned long last_recalibration;
    
    // ×–×™×”×•×™ ×™×¦×™×‘×•×ª ××ª×§×“×
    float stability_buffer[10];  // ×××’×¨ ×©×œ 10 ×§×¨×™××•×ª ××—×¨×•× ×•×ª
    int stability_index;
    bool is_stable;
    float current_stability_baseline_x, current_stability_baseline_y, current_stability_baseline_z;
    unsigned long stability_start_time;
    
    // ×–×™×”×•×™ ×ª× ×•×¢×” ×××™×ª×™×ª (××›×”)
    float acceleration_peak;
    bool in_motion;
    unsigned long motion_start_time;
    
    // ×× ×™×¢×ª ××›×•×ª ×›×•×–×‘×•×ª
    float variance_threshold;
    bool recently_moved;
    unsigned long last_significant_motion;
};

SensorData sensor1; // ×¢×œ×™×•×Ÿ (×¨××©/×’×•×£)
SensorData sensor2; // ×ª×—×ª×•×Ÿ (×›×‘×“)

// ××©×ª× ×™× ×’×œ×•×‘×œ×™×™×
unsigned long training_start_time = 0;
int total_punches = 0;
String session_id = "";

// ×”×’×“×¨×•×ª ××¢×§×‘ ××’×¨×•×¤×™× - ××ª×§×“××•×ª ×œ×× ×™×¢×ª ××›×•×ª ×›×•×–×‘×•×ª
float PUNCH_THRESHOLD = 0.8;
const unsigned long COOLDOWN_BETWEEN_PUNCHES = 120;  // 120ms = 8.3 ××›×•×ª/×©× ×™×™×”
const unsigned long SENSOR_RESET_TIME = 50;         // 50ms = ×–××Ÿ ××™× ×™××œ×™ ×œ×–×™×”×•×™ ××›×” ×—×“×©×”

// ×”×’×“×¨×•×ª ×™×¦×™×‘×•×ª ×—×“×©×•×ª - ××ª×§×“××•×ª
const int STABILITY_REQUIRED_SAMPLES = 8;           // 8 ×“×’×™××•×ª ×™×¦×™×‘×•×ª = 80ms
const float STABILITY_VARIANCE_THRESHOLD = 0.02;    // ×¨×£ ×©×•× ×•×ª × ××•×š ×œ×™×¦×™×‘×•×ª
const unsigned long MIN_STABILITY_TIME = 200;       // 200ms ××™× ×™××•× ×™×¦×™×‘×•×ª
const unsigned long SIGNIFICANT_MOTION_COOLDOWN = 300; // 300ms ×œ××—×¨ ×ª× ×•×¢×” ××©××¢×•×ª×™×ª

// ×œ××™×“×” ××•×˜×•××˜×™×ª
const int LEARNING_SAMPLE_SIZE = 10;
float learning_forces[LEARNING_SAMPLE_SIZE];
int learning_index = 0;
bool learning_complete = false;

// ××©×ª× ×™× ×œ×©×œ×™×—×ª × ×ª×•× ×™×
unsigned long last_data_send = 0;
const unsigned long DATA_SEND_INTERVAL = 100; // ×©×œ×™×—×” ×›×œ 100ms
unsigned long last_status_send = 0;
const unsigned long STATUS_SEND_INTERVAL = 1000; // ×¡×˜×˜×•×¡ ×›×œ ×©× ×™×™×”

// ×”×›×¨×–×•×ª ×¤×•× ×§×¦×™×•×ª
void resetSensorData(SensorData* sensor);
void initMPU6050(TwoWire* wire, const char* name, byte addr);
void readSensor(TwoWire* wire, SensorData* sensor, byte addr);
void updateStabilityTracking(SensorData* sensor, float ax, float ay, float az);
bool isCurrentlyStable(SensorData* sensor);
float calculateVariance(float* buffer, int size, float mean);
void updateMovingBaseline(SensorData* sensor, float ax, float ay, float az);
void detectPunch(SensorData* sensor);
void detectSmartPunch();
float calculateCombinedForce(int primary_sensor);
void adaptToUser(float force);
void calibrateSensor(TwoWire* wire, SensorData* sensor, const char* name, byte addr);
void sendDataToBluetooth();
void sendStatusToBluetooth();
void sendPunchEventToBluetooth(int sensor_num, String zone, float force, float combined_force, float bpm);
void handleBluetoothCommands();
void resetTraining();
void calibrateAllSensors();
void printStatus();
float roundFloat(float value, int decimals);

void setup() {
    Serial.begin(115200);
    delay(1000);
    
    Serial.println("=== ×—×™×™×©×Ÿ ××’×¨×•×£ ××ª×§×“× - ×œ×œ× ××›×•×ª ×›×•×–×‘×•×ª ===");
    Serial.println("×××ª×—×œ ××¢×¨×›×ª...");
    
    // ××™×¤×•×¡ ××©×ª× ×™×
    resetSensorData(&sensor1);
    resetSensorData(&sensor2);
    total_punches = 0;
    training_start_time = millis();
    session_id = "session_" + String(millis());
    
    // ××ª×—×•×œ I2C
    Serial.println("ğŸ”§ ×××ª×—×œ I2C buses...");
    I2C_1.begin(SDA1, SCL1, 100000);
    I2C_2.begin(SDA2, SCL2, 100000);
    
    Serial.printf("I2C_1: SDA=%d, SCL=%d (×›×ª×•×‘×ª 0x%02X)\n", SDA1, SCL1, MPU6050_ADDR1);
    Serial.printf("I2C_2: SDA=%d, SCL=%d (×›×ª×•×‘×ª 0x%02X)\n", SDA2, SCL2, MPU6050_ADDR2);
    
    delay(100);
    
    // ××ª×—×•×œ ×—×™×™×©× ×™×
    Serial.println("\nğŸ“¡ ×××ª×—×œ ×—×™×™×©× ×™×...");
    initMPU6050(&I2C_1, "×¢×œ×™×•×Ÿ (×¨××©/×’×•×£)", MPU6050_ADDR1);
    initMPU6050(&I2C_2, "×ª×—×ª×•×Ÿ (×›×‘×“)", MPU6050_ADDR2);
    
    delay(500);
    
    // ×§×œ×™×‘×¨×¦×™×” ×¨××©×•× ×™×ª
    Serial.println("\nâš–ï¸ ××›×™×™×œ ×—×™×™×©× ×™×...");
    calibrateSensor(&I2C_1, &sensor1, "×¢×œ×™×•×Ÿ", MPU6050_ADDR1);
    calibrateSensor(&I2C_2, &sensor2, "×ª×—×ª×•×Ÿ", MPU6050_ADDR2);
    
    // ××ª×—×•×œ ×‘×œ×•×˜×•×ª'
    Serial.println("\nğŸ”µ ××¤×¢×™×œ ×‘×œ×•×˜×•×ª'...");
    if (!SerialBT.begin(device_name)) {
        Serial.println("âŒ ×©×’×™××” ×‘××ª×—×•×œ ×‘×œ×•×˜×•×ª'!");
        return;
    }
    
    Serial.println("âœ… ×‘×œ×•×˜×•×ª' ××•×¤×¢×œ ×‘×”×¦×œ×—×”!");
    Serial.print("ğŸ“± ×©× ×”××›×©×™×¨: ");
    Serial.println(device_name);
    Serial.println("â³ ×××ª×™×Ÿ ×œ×—×™×‘×•×¨ ××”××¤×œ×™×§×¦×™×”...");
    
    Serial.println("\nğŸ¥Š ××¢×¨×›×ª ××•×›× ×” ×œ××™××•×Ÿ!");
    Serial.println("ğŸ›¡ï¸  ××¢×¨×›×ª ××ª×§×“××ª ×œ×× ×™×¢×ª ××›×•×ª ×›×•×–×‘×•×ª ××•×¤×¢×œ×ª!");
    Serial.println("ğŸ“‹ ×œ×•×’ ×¤×¢×™×œ×•×ª:");
    Serial.println("================");
}

void loop() {
    // ×§×¨×™××ª × ×ª×•× ×™ ×—×™×™×©× ×™×
    readSensor(&I2C_1, &sensor1, MPU6050_ADDR1);
    delay(2);
    readSensor(&I2C_2, &sensor2, MPU6050_ADDR2);
    
    // ×–×™×”×•×™ ××›×•×ª
    detectPunch(&sensor1);
    detectPunch(&sensor2);
    detectSmartPunch();
    
    // ×¢×“×›×•×Ÿ ×¡×™×›×•×
    total_punches = sensor1.punch_count + sensor2.punch_count;
    
    // ×©×œ×™×—×ª × ×ª×•× ×™× ×œ××¤×œ×™×§×¦×™×”
    sendDataToBluetooth();
    
    // ×˜×™×¤×•×œ ×‘×¤×§×•×“×•×ª ××”××¤×œ×™×§×¦×™×”
    handleBluetoothCommands();
    
    // ×”×“×¤×¡×ª ××¦×‘ ×‘-Serial ×›×œ 3 ×©× ×™×•×ª
    static unsigned long last_status = 0;
    if (millis() - last_status > 3000) {
        printStatus();
        last_status = millis();
    }
    
    delay(10); // ×“×’×™××” ××”×™×¨×” - 100Hz
}

void resetSensorData(SensorData* sensor) {
    sensor->current_punch = 0.0;
    sensor->max_punch = 0.0;
    sensor->punch_count = 0;
    sensor->baseline_x = 0.0;
    sensor->baseline_y = 0.0;
    sensor->baseline_z = 0.0;
    sensor->punch_detected = false;
    sensor->last_detection = 0;
    sensor->last_punch_time = 0;
    sensor->moving_avg_x = 0.0;
    sensor->moving_avg_y = 0.0;
    sensor->moving_avg_z = 0.0;
    sensor->stable_count = 0;
    sensor->last_recalibration = 0;
    
    // ××™×¤×•×¡ ××¢×¨×›×ª ×™×¦×™×‘×•×ª ××ª×§×“××ª
    sensor->stability_index = 0;
    sensor->is_stable = false;
    sensor->current_stability_baseline_x = 0.0;
    sensor->current_stability_baseline_y = 0.0;
    sensor->current_stability_baseline_z = 0.0;
    sensor->stability_start_time = 0;
    sensor->acceleration_peak = 0.0;
    sensor->in_motion = false;
    sensor->motion_start_time = 0;
    sensor->variance_threshold = STABILITY_VARIANCE_THRESHOLD;
    sensor->recently_moved = false;
    sensor->last_significant_motion = 0;
    
    // ××™×¤×•×¡ ×××’×¨ ×™×¦×™×‘×•×ª
    for (int i = 0; i < 10; i++) {
        sensor->stability_buffer[i] = 0.0;
    }
}

void initMPU6050(TwoWire* wire, const char* name, byte addr) {
    Serial.print("ğŸ“¡ ×××ª×—×œ ");
    Serial.print(name);
    Serial.print(" (0x");
    Serial.print(addr, HEX);
    Serial.print(")...");
    
    wire->beginTransmission(addr);
    byte error = wire->endTransmission();
    
    if (error == 0) {
        Serial.println(" ×–×•×”×”!");
        
        // ××ª×—×•×œ ×”×—×™×™×©×Ÿ
        wire->beginTransmission(addr);
        wire->write(0x6B);  // PWR_MGMT_1 register
        wire->write(0);     // wake up the sensor
        wire->endTransmission(true);
        delay(100);
        
        // ×‘×“×™×§×ª WHO_AM_I
        wire->beginTransmission(addr);
        wire->write(0x75);  // WHO_AM_I register
        wire->endTransmission(false);
        wire->requestFrom(addr, 1, true);
        
        if (wire->available()) {
            byte whoami = wire->read();
            Serial.print("âœ“ ");
            Serial.print(name);
            Serial.print(" ××—×•×‘×¨ (ID: 0x");
            Serial.print(whoami, HEX);
            Serial.println(")");
        }
    } else {
        Serial.print(" âŒ ×©×’×™××” ");
        Serial.print(error);
        Serial.println(" - ×‘×“×•×§ ×—×™×•×•×˜!");
    }
}

void readSensor(TwoWire* wire, SensorData* sensor, byte addr) {
    wire->beginTransmission(addr);
    wire->write(0x3B);
    byte error = wire->endTransmission(false);
    
    if (error != 0) {
        sensor->current_punch = 0.0;
        return;
    }
    
    wire->requestFrom(addr, 6, true);
    
    if (wire->available() >= 6) {
        int16_t ax = (wire->read() << 8) | wire->read();
        int16_t ay = (wire->read() << 8) | wire->read();
        int16_t az = (wire->read() << 8) | wire->read();
        
        float ax_g = ax / 16384.0;
        float ay_g = ay / 16384.0;
        float az_g = az / 16384.0;
        
        // ×¢×“×›×•×Ÿ ××¢×§×‘ ×™×¦×™×‘×•×ª ××ª×§×“×
        updateStabilityTracking(sensor, ax_g, ay_g, az_g);
        
        // ×¢×“×›×•×Ÿ baseline ×¨×§ ×›×©×‘×××ª × ×“×¨×©
        updateMovingBaseline(sensor, ax_g, ay_g, az_g);
        
        // ×—×™×©×•×‘ ×”×”×¤×¨×© ××”×‘×¡×™×¡ ×”× ×•×›×—×™ (×™×¦×™×‘)
        float diff_x, diff_y, diff_z;
        
        if (sensor->is_stable) {
            // ×× ×™×¦×™×‘ - ×”×©×ª××© ×‘baseline ×”× ×•×›×—×™ ×”×™×¦×™×‘
            diff_x = ax_g - sensor->current_stability_baseline_x;
            diff_y = ay_g - sensor->current_stability_baseline_y;
            diff_z = az_g - sensor->current_stability_baseline_z;
        } else {
            // ×× ×œ× ×™×¦×™×‘ - ×”×©×ª××© ×‘×××•×¦×¢ ×”× ×¢
            diff_x = ax_g - sensor->moving_avg_x;
            diff_y = ay_g - sensor->moving_avg_y;
            diff_z = az_g - sensor->moving_avg_z;
        }
        
        float magnitude = sqrt(diff_x*diff_x + diff_y*diff_y + diff_z*diff_z);
        
        // ×¨×§ ×ª× ×•×¢×•×ª ×—×–×§×•×ª ××¢×œ ×”×¨×£ × ×—×©×‘×•×ª ×›××›×•×ª
        // ×•×‘×ª× ××™ ×©×œ× ×‘××¦×‘ ×™×¦×™×‘ ××• ×©×™×© ×ª× ×•×¢×” ××©××¢×•×ª×™×ª
        unsigned long current_time = millis();
        bool significant_motion_recently = (current_time - sensor->last_significant_motion) < SIGNIFICANT_MOTION_COOLDOWN;
        
        if (magnitude > PUNCH_THRESHOLD && (!sensor->is_stable || significant_motion_recently)) {
            sensor->current_punch = magnitude;
            sensor->in_motion = true;
            sensor->motion_start_time = current_time;
            sensor->last_significant_motion = current_time;
            
            // ×¢×“×›×•×Ÿ ×¤×™×§ ×”×ª××•×¦×”
            if (magnitude > sensor->acceleration_peak) {
                sensor->acceleration_peak = magnitude;
            }
        } else if (sensor->is_stable && !significant_motion_recently) {
            // ×‘××¦×‘ ×™×¦×™×‘ ×œ×œ× ×ª× ×•×¢×” ××©××¢×•×ª×™×ª - ××¤×¡ ×›×“×™ ×œ×× ×•×¢ ××›×•×ª ×›×•×–×‘×•×ª
            sensor->current_punch = 0.0;
        } else {
            sensor->current_punch = magnitude;
        }
        
        // ×¢×“×›×•×Ÿ ××§×¡×™××•×
        if (sensor->current_punch > sensor->max_punch) {
            sensor->max_punch = sensor->current_punch;
        }
        
        // ××™×¤×•×¡ ××¦×‘ ×ª× ×•×¢×” ×× ×”×¢×•×¦××” ×™×¨×“×”
        if (magnitude < PUNCH_THRESHOLD * 0.2) {
            sensor->in_motion = false;
            sensor->acceleration_peak = 0.0;
        }
    } else {
        sensor->current_punch = 0.0;
    }
    
    delay(1);
}

// ×¤×•× ×§×¦×™×” ×—×“×©×”: ××¢×§×‘ ×™×¦×™×‘×•×ª ××ª×§×“×
void updateStabilityTracking(SensorData* sensor, float ax, float ay, float az) {
    unsigned long current_time = millis();
    
    // ×—×™×©×•×‘ magnitude ×›×•×œ×œ
    float total_magnitude = sqrt(ax*ax + ay*ay + az*az);
    
    // ×”×•×¡×¤×” ×œ×××’×¨ ×™×¦×™×‘×•×ª
    sensor->stability_buffer[sensor->stability_index] = total_magnitude;
    sensor->stability_index = (sensor->stability_index + 1) % 10;
    
    // ×—×™×©×•×‘ ×××•×¦×¢ ×•×©×•× ×•×ª ×©×œ ×”×××’×¨
    float mean = 0;
    for (int i = 0; i < 10; i++) {
        mean += sensor->stability_buffer[i];
    }
    mean /= 10.0;
    
    float variance = calculateVariance(sensor->stability_buffer, 10, mean);
    
    // ×‘×“×™×§×ª ×™×¦×™×‘×•×ª
    bool currently_stable = (variance < sensor->variance_threshold);
    
    if (currently_stable && !sensor->is_stable) {
        // ×”×ª×—×œ×ª ××¦×‘ ×™×¦×™×‘×•×ª ×—×“×©
        sensor->is_stable = true;
        sensor->stability_start_time = current_time;
        sensor->current_stability_baseline_x = ax;
        sensor->current_stability_baseline_y = ay;
        sensor->current_stability_baseline_z = az;
        
        Serial.print("ğŸ”’ ×™×¦×™×‘×•×ª ×–×•×”×ª×” - baseline ×—×“×©: (");
        Serial.print(ax, 2);
        Serial.print(", ");
        Serial.print(ay, 2);
        Serial.print(", ");
        Serial.print(az, 2);
        Serial.println(")");
        
    } else if (currently_stable && sensor->is_stable) {
        // ×”××©×š ××¦×‘ ×™×¦×™×‘×•×ª - ×¢×“×›×•×Ÿ ×¢×“×™×Ÿ ×©×œ ×”baseline
        if ((current_time - sensor->stability_start_time) > MIN_STABILITY_TIME) {
            const float alpha = 0.01; // ×¢×“×›×•×Ÿ ××™×˜×™ ×××•×“
            sensor->current_stability_baseline_x = sensor->current_stability_baseline_x * (1 - alpha) + ax * alpha;
            sensor->current_stability_baseline_y = sensor->current_stability_baseline_y * (1 - alpha) + ay * alpha;
            sensor->current_stability_baseline_z = sensor->current_stability_baseline_z * (1 - alpha) + az * alpha;
        }
        
    } else if (!currently_stable && sensor->is_stable) {
        // ×™×¦×™××” ×××¦×‘ ×™×¦×™×‘×•×ª
        sensor->is_stable = false;
        sensor->last_significant_motion = current_time;
        
        Serial.println("ğŸ”“ ×™×¦×™××” ×××¦×‘ ×™×¦×™×‘×•×ª - ××›×•×ª ×™×›×•×œ×•×ª ×œ×”×™×¡×¤×¨");
    }
}

// ×¤×•× ×§×¦×™×” ×¢×–×¨: ×—×™×©×•×‘ ×©×•× ×•×ª
float calculateVariance(float* buffer, int size, float mean) {
    float variance = 0;
    for (int i = 0; i < size; i++) {
        variance += pow(buffer[i] - mean, 2);
    }
    return variance / size;
}

// ×‘×“×™×§×” ×”×× ×”×—×™×™×©×Ÿ ×™×¦×™×‘ ×›×¨×’×¢
bool isCurrentlyStable(SensorData* sensor) {
    return sensor->is_stable && 
           (millis() - sensor->stability_start_time) > MIN_STABILITY_TIME &&
           (millis() - sensor->last_significant_motion) > SIGNIFICANT_MOTION_COOLDOWN;
}

// ×¢×“×›×•×Ÿ baseline - ×¨×§ ×›×©×‘×××ª ×™×¦×™×‘ ×œ×–××Ÿ ××¨×•×š
void updateMovingBaseline(SensorData* sensor, float ax, float ay, float az) {
    // ×¢×“×›×•×Ÿ ×¨×§ ×›×©×™×¦×™×‘ ×××•×“ ×•×œ×–××Ÿ ××¨×•×š
    if (isCurrentlyStable(sensor)) {
        sensor->stable_count++;
        
        // ×›×™×•×œ ××—×“×© ×¨×§ ××—×¨×™ ×™×¦×™×‘×•×ª ××¨×•×›×” ×××•×“ (30 ×©× ×™×•×ª!)
        if (sensor->stable_count > 3000) { // 30 ×©× ×™×•×ª ×‘-100Hz
            sensor->baseline_x = sensor->current_stability_baseline_x;
            sensor->baseline_y = sensor->current_stability_baseline_y;
            sensor->baseline_z = sensor->current_stability_baseline_z;
            
            sensor->moving_avg_x = sensor->baseline_x;
            sensor->moving_avg_y = sensor->baseline_y;
            sensor->moving_avg_z = sensor->baseline_z;
            
            sensor->stable_count = 0;
            
            Serial.println("ğŸ”§ ×›×™×•×œ ××•×˜×•××˜×™ - ×™×¦×™×‘×•×ª ××¨×•×›×” ×××•×“ (30 ×©× ×™×•×ª)");
        }
    } else {
        // ×™×© ×ª× ×•×¢×” - ××™×¤×•×¡ ×¡×¤×™×¨×”
        sensor->stable_count = 0;
    }
}

void detectPunch(SensorData* sensor) {
    unsigned long current_time = millis();
    
    // ×–×™×”×•×™ ××›×” ××ª×§×“× - ×¨×§ ×× ×œ× ×‘××¦×‘ ×™×¦×™×‘ ××• ×™×© ×ª× ×•×¢×” ××©××¢×•×ª×™×ª
    bool can_detect_punch = !isCurrentlyStable(sensor) || 
                           (current_time - sensor->last_significant_motion) < SIGNIFICANT_MOTION_COOLDOWN;
    
    if (sensor->current_punch > PUNCH_THRESHOLD && 
        !sensor->punch_detected && 
        can_detect_punch &&
        (current_time - sensor->last_detection > SENSOR_RESET_TIME)) {
        
        sensor->punch_detected = true;
        sensor->last_detection = current_time;
    }
    
    // ××™×¤×•×¡ ×–×™×”×•×™ ××›×”
    if (sensor->current_punch < PUNCH_THRESHOLD * 0.3) {
        sensor->punch_detected = false;
    }
}

void detectSmartPunch() {
    static unsigned long last_smart_detection = 0;
    unsigned long current_time = millis();
    
    // ×‘×“×™×§×” ×©×™×© ×–×™×”×•×™ ×‘×—×™×™×©×Ÿ
    bool any_punch = sensor1.punch_detected || sensor2.punch_detected;
    
    if (any_punch && (current_time - last_smart_detection > COOLDOWN_BETWEEN_PUNCHES)) {
        // ××™×–×” ×—×™×™×©×Ÿ ×”×›×™ ×—×–×§?
        float max_force = 0;
        int winning_sensor = 0;
        String winning_zone = "";
        
        if (sensor1.current_punch > max_force && sensor1.current_punch > PUNCH_THRESHOLD) {
            max_force = sensor1.current_punch;
            winning_sensor = 1;
            winning_zone = "×¢×œ×™×•×Ÿ";
        }
        
        if (sensor2.current_punch > max_force && sensor2.current_punch > PUNCH_THRESHOLD) {
            max_force = sensor2.current_punch;
            winning_sensor = 2;
            winning_zone = "×ª×—×ª×•×Ÿ";
        }
        
        // ×× ×™×© ×–×•×›×” ×‘×¨×•×¨
        if (winning_sensor > 0) {
            // ×‘×“×™×§×” × ×•×¡×¤×ª: ×”×× ×”××›×” ×œ×’×™×˜×™××™×ª?
            SensorData* winning_sensor_data = (winning_sensor == 1) ? &sensor1 : &sensor2;
            bool legitimate_punch = !isCurrentlyStable(winning_sensor_data) ||
                                   (current_time - winning_sensor_data->last_significant_motion) < SIGNIFICANT_MOTION_COOLDOWN;
            
            if (legitimate_punch) {
                // ×¨×§ ×”×—×™×™×©×Ÿ ×”×–×•×›×” ××§×‘×œ × ×§×•×“×”
                if (winning_sensor == 1) {
                    sensor1.punch_count++;
                    sensor1.last_punch_time = current_time;
                } else {
                    sensor2.punch_count++;
                    sensor2.last_punch_time = current_time;
                }
                
                // ×—×™×©×•×‘ ×¢×•×¦××” ××©×•×œ×‘×ª
                float combined_force = calculateCombinedForce(winning_sensor);
                
                // ×—×™×©×•×‘ BPM
                static unsigned long last_punch_time_for_bpm = 0;
                unsigned long time_between_punches = current_time - last_punch_time_for_bpm;
                float bpm = 0;
                if (last_punch_time_for_bpm > 0 && time_between_punches > 0) {
                    bpm = 60000.0 / time_between_punches;
                }
                
                // ×œ××™×“×” ××•×˜×•××˜×™×ª
                if (!learning_complete) {
                    adaptToUser(combined_force);
                }
                
                last_punch_time_for_bpm = current_time;
                
                Serial.print("ğŸ¥Š ××›×” ");
                Serial.print(winning_zone);
                Serial.print(" #");
                Serial.print((winning_sensor == 1 ? sensor1.punch_count : sensor2.punch_count));
                Serial.print(" ×¢×•×¦××”: ");
                Serial.print(max_force, 2);
                Serial.print(" (××©×•×œ×‘: ");
                Serial.print(combined_force, 2);
                Serial.print(")");
                
                // ×”×•×¡×¤×ª ××™×“×¢ ×¢×œ ××¦×‘ ×™×¦×™×‘×•×ª
                bool sensor_stable = isCurrentlyStable(winning_sensor_data);
                Serial.print(" [");
                Serial.print(sensor_stable ? "×™×¦×™×‘" : "×‘×ª× ×•×¢×”");
                Serial.print("]");
                
                if (bpm > 0 && bpm < 300) {
                    Serial.print(" BPM: ");
                    Serial.print(bpm, 0);
                }
                
                if (!learning_complete) {
                    Serial.print(" [×œ××™×“×” ");
                    Serial.print(learning_index);
                    Serial.print("/");
                    Serial.print(LEARNING_SAMPLE_SIZE);
                    Serial.print("]");
                }
                
                Serial.print(" | ×¡×”''×›: ");
                Serial.println(sensor1.punch_count + sensor2.punch_count);
                
                // ×©×œ×™×—×” ×œ××¤×œ×™×§×¦×™×”
                sendPunchEventToBluetooth(winning_sensor, winning_zone, max_force, combined_force, bpm);
                
                last_smart_detection = current_time;
            } else {
                Serial.println("ğŸš« ××›×” × ×—×¡××” - ×—×™×™×©×Ÿ ×‘××¦×‘ ×™×¦×™×‘");
            }
        }
    }
}

float calculateCombinedForce(int primary_sensor) {
    float primary_force = 0;
    float secondary_boost = 0;
    
    if (primary_sensor == 1) {
        primary_force = sensor1.current_punch;
        secondary_boost = sensor2.current_punch * 0.2;
    } else {
        primary_force = sensor2.current_punch;
        secondary_boost = sensor1.current_punch * 0.2;
    }
    
    return primary_force + secondary_boost;
}

void adaptToUser(float force) {
    if (learning_index < LEARNING_SAMPLE_SIZE) {
        learning_forces[learning_index] = force;
        learning_index++;
        
        if (learning_index >= LEARNING_SAMPLE_SIZE) {
            // ×—×™×©×•×‘ ×××•×¦×¢
            float avg_force = 0;
            for (int i = 0; i < LEARNING_SAMPLE_SIZE; i++) {
                avg_force += learning_forces[i];
            }
            avg_force /= LEARNING_SAMPLE_SIZE;
            
            // ×§×‘×™×¢×ª ×¨×£ ×—×“×©
            PUNCH_THRESHOLD = avg_force * 0.7;
            if (PUNCH_THRESHOLD < 0.3) PUNCH_THRESHOLD = 0.3;
            if (PUNCH_THRESHOLD > 1.5) PUNCH_THRESHOLD = 1.5;
            
            learning_complete = true;
            
            Serial.println("\nâœ… ×œ××™×“×” ×”×•×©×œ××”!");